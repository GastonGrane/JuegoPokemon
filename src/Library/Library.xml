<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Library</name>
    </assembly>
    <members>
        <member name="T:Library.Attack">
            <summary>
            Clase base abstracta que representa un ataque en el juego, proporcionando propiedades esenciales
            que definen las características de cada ataque.
            </summary>
            <remarks>
            La clase <see cref="T:Library.Attack"/> sirve como base para varios tipos de ataques especificos.
            Esta clase cumple con LSP (Liskov Subsititution Principle) debido a que en los objetos de las subclases creadas a partir
            de esta se va a generar el mismo comportamiento que en la superclase, así logrando la posibilidad de poder utilizar los objetos de las subclases
            donde se usan los objetos de la superclase, y logrando comportamiento coherente.
            Cumple también con OCP "Open-Closed Principle", ya que permite
            la extensión a través de subclases como <see cref="T:Library.NormalAttack"/> o <see cref="T:Library.SpecialAttack"/> sin necesidad de
            modificar el código base.
            Finalmente, implementa el patrón GRASP de "Polimorfismo", ya que se espera que las subclases concreten comportamientos específicos.
            Estas instancias predefinidas las creamos para utilziarlas como un movimiento en las batallas.
            </remarks>
        </member>
        <member name="M:Library.Attack.#ctor(System.String,System.Int32,Library.PokemonType,System.Int32)">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:Library.Attack"/> con los parámetros especificados.
            </summary>
            <param name="name">El nombre del ataque.</param>
            <param name="damage">La cantidad de daño que causa el ataque.</param>
            <param name="type">El tipo de ataque (<see cref="T:Library.PokemonType"/>), que determina su efectividad.</param>
            <param name="precision">La precision del ataque (1-100).</param>
        </member>
        <member name="M:Library.Attack.#ctor(Library.Attack)">
            <summary>
            Crea un <see cref="T:Library.Attack"/> copiando los valores del ataque provisto.
            </summary>
            <param name="attack">El ataque a copiar.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="attack"/> es <c>null</c>.
            </exception>
        </member>
        <member name="P:Library.Attack.Name">
            <summary>
            Obtiene el nombre del ataque.
            </summary>
        </member>
        <member name="P:Library.Attack.Damage">
            <summary>
            Obtiene el valor de daño del ataque.
            </summary>
        </member>
        <member name="P:Library.Attack.Type">
            <summary>
            Obtiene el tipo de ataque, que determina la efectividad del ataque contra diferentes tipos de Pokémon.
            </summary>
        </member>
        <member name="P:Library.Attack.Precision">
            <summary>
            Obtiene la precisión del ataque, representada como un porcentaje entre 1 y 100.
            </summary>
        </member>
        <member name="M:Library.Attack.Use(Library.Pokemon)">
            <summary>
            Aplica el ataque a un Pokémon objetivo. Debe ser implementado por clases derivadas.
            </summary>
            <param name="target">El Pokémon objetivo al que se aplicará el ataque.</param>
        </member>
        <member name="T:Library.NormalAttack">
            <summary>
            Representa un ataque básico en el juego. A diferencia de <see cref="T:Library.SpecialAttack"/>,
            <see cref="T:Library.NormalAttack"/> no utiliza efectos y solo inflige daño directo al Pokémon objetivo.
            </summary>
            <remarks>
            Esta clase cumple con SRP, al abarcar la funcionalidad de un único tipo de ataque, aquellos que únicamente producen daño.
            La clase <see cref="T:Library.NormalAttack"/> permite crear instancias de ataques predefinidos para ser utilizados
            en las batallas, y se beneficia del "Polimorfismo" del patrón GRASP al heredar de la clase base <see cref="T:Library.Attack"/>.
            </remarks>
        </member>
        <member name="M:Library.NormalAttack.#ctor(System.String,System.Int32,Library.PokemonType,System.Int32)">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:Library.NormalAttack"/>.
            </summary>
            <param name="name">El nombre del ataque.</param>
            <param name="damage">La cantidad de danio que genera.</param>
            <param name="type">El <see cref="T:Library.PokemonType"/> que va a definir el elemento del ataque.</param>
            <param name="precision">La precision del ataque (1-100).</param>
            <exception cref="T:System.ArgumentNullException">
            Lanzado si <paramref name="name"/> es <c>null</c>.
            </exception>
            <remarks>
            Este constructor lo utilizamos internamente para crear las caracteristicas de cada ataque.
            </remarks>
        </member>
        <member name="M:Library.NormalAttack.#ctor(Library.NormalAttack)">
            <summary>
            Constructor que copia los valores de una instancia de la clase <see cref="T:Library.NormalAttack"/>.
            </summary>
            <param name="attack">El ataque a copiar.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="attack"/> es <c>null</c>.
            </exception>
        </member>
        <member name="M:Library.NormalAttack.Use(Library.Pokemon)">
            <summary>
            Aplica el ataque normal al Pokémon objetivo, calculando el daño con base en la ventaja de tipo.
            </summary>
            <param name="target">El Pokémon objetivo que recibirá el daño.</param>
            <exception cref="T:System.ArgumentNullException">Lanzado si el Pokémon objetivo es <c>null</c>.</exception>
        </member>
        <member name="T:Library.NormalAttackRegistry">
            <summary>
            Clase estática con una colección de ataques normales pre-definidos.
            </summary>
            <remarks>
            Se podría decir que es una implementación de <see href="https://refactoring.guru/design-patterns/prototype">Prototype</see>.
            Esto es porque esta clase permite conseguir un objeto de la clase NormalAttack sin conocer su estructura, a través de el nombre del objeto, clonando un prototipo pre-definido.
            </remarks>
        </member>
        <member name="M:Library.NormalAttackRegistry.GetNormalAttack(System.String)">
            <summary>
            Retorna una copia del <see cref="T:Library.NormalAttack"/> cuyo nombre es <paramref name="name"/>, si se encuentra en el registro.
            </summary>
            <param name="name">El nombre del <see cref="T:Library.NormalAttack"/>.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Si el <see cref="T:Library.NormalAttack"/> no está en el registro.
            </exception>
            <returns>
            Una copia del <see cref="T:Library.NormalAttack"/> cuyo nombre es <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Library.NormalAttackRegistry.GetAttackNamesAndTypes">
            <summary>
            Retorna una lista de tuplas donde cada una es el nombre y tipo de un ataque del registro.
            </summary>
            <returns>
            Lista de (Nombre, Tipo).
            </returns>
        </member>
        <member name="T:Library.SpecialAttack">
            <summary>
            Representa un ataque especial que, además de causar daño, también inflige un estado en el Pokémon objetivo,
            dependiendo del tipo de ataque que se utilice. Una vez que el ataque acierta, el estado se aplica
            con un 100% de precisión.
            </summary>
        </member>
        <member name="M:Library.SpecialAttack.#ctor(System.String,System.Int32,Library.PokemonType,System.Int32,Library.Effect.IEffect)">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:Library.SpecialAttack"/>.
            </summary>
            <param name="name">El nombre del ataque.</param>
            <param name="damage">La cantidad de daño que realiza.</param>
            <param name="attackType">El <see cref="T:Library.PokemonType"/> del ataque.</param>
            <param name="precision">La precisión del ataque (1-100).</param>
            <param name="effect">El efecto del ataque.</param>
        </member>
        <member name="M:Library.SpecialAttack.#ctor(Library.SpecialAttack)">
            <summary>
            Constructor que copia los valores de una instancia de la clase <see cref="T:Library.SpecialAttack"/>.
            </summary>
            <param name="attack">El ataque a copiar.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="attack"/> es <c>null</c>.
            </exception>
        </member>
        <member name="M:Library.SpecialAttack.Use(Library.Pokemon)">
            <summary>
            Aplica el daño y el efecto especial al Pokémon objetivo. Si el Pokémon objetivo no tiene un efecto
            activo, se le aplica el efecto de este ataque.
            </summary>
            <param name="target">El Pokémon objetivo que recibirá el efecto especial.</param>
            <exception cref="T:System.ArgumentNullException">Se lanza si el Pokémon objetivo es <c>null</c>.</exception>
        </member>
        <member name="T:Library.SpecialAttackRegistry">
            <summary>
            Clase estática con una colección de ataques especiales pre-definidos.
            </summary>
            <remarks>
            Se podría decir que es una implementación de <see href="https://refactoring.guru/design-patterns/prototype">Prototype</see>.
            Esto es porque esta clase permite conseguir un objeto de la clase SpecialAttack sin conocer su estructura, a través de el nombre del objeto, clonando un prototipo pre-definido.
            </remarks>
        </member>
        <member name="M:Library.SpecialAttackRegistry.GetSpecialAttack(System.String)">
            <summary>
            Retorna una copia del <see cref="T:Library.SpecialAttack"/> cuyo nombre es <paramref name="name"/>, si se encuentra en el registro.
            </summary>
            <param name="name">El nombre del <see cref="T:Library.SpecialAttack"/>.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Si el <see cref="T:Library.SpecialAttack"/> no está en el registro.
            </exception>
            <returns>
            Una copia del <see cref="T:Library.SpecialAttack"/> cuyo nombre es <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Library.SpecialAttackRegistry.GetAttackNamesAndTypes">
            <summary>
            Retorna una lista de tuplas donde cada una es el nombre y tipo de un ataque del registro.
            </summary>
            <returns>
            Lista de (Nombre, Tipo).
            </returns>
        </member>
        <member name="T:Library.Effect.Burn">
            <summary>
            Representa un efecto de quemadura que puede ser aplicado a un Pokémon.
            Este efecto causa daño al Pokémon objetivo cada turno mientras está activo.
            </summary>
            <remarks>
            Esta clase cumple con SRP (Single Responsibility Principle) ya que tiene una unica responsabilidad, manejar la
            logica del efecto Burn.
            </remarks>
        </member>
        <member name="M:Library.Effect.Burn.#ctor">
            <summary>
            Inicializa una nueva instancia del efecto de quemadura en el Pokémon especificado y lo marca como activo.
            </summary>
        </member>
        <member name="P:Library.Effect.Burn.IsExpired">
            <summary>
            Indica si el efecto de quemadura ha expirado y ya no debe aplicarse.
            </summary>
        </member>
        <member name="M:Library.Effect.Burn.UpdateEffect(Library.Pokemon)">
            <summary>
            Aplica el daño de quemadura al Pokémon objetivo, reduciendo su salud en un 10% de su salud actual.
            </summary>
            <param name="target">El Pokémon al que se le aplicará el daño por quemadura.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="M:Library.Effect.Burn.RemoveEffect(Library.Pokemon)">
            <summary>
            Elimina el efecto de quemadura del Pokémon, marcándolo como expirado.
            </summary>
            <param name="target">El Pokémon del que se removerá el efecto.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="T:Library.Effect.IEffect">
            <summary>
            Define una interfaz para los efectos que se pueden aplicar a un Pokémon.
            Los efectos pueden actualizarse en cada turno, eliminarse y expirar.
            </summary>
            <remarks>
            Implementa el principio ISP (Interface Segregation Principle) al proporcionar una interfaz específica
            para los efectos, la cual todos ecesitan utilizar
            Aplica el patrón GRASP de "Polimorfismo" al permitir que cada tipo de efecto defina su propio
            comportamiento, cumple así con el el principio "Open-Closed Principle" al facilitar la extensión de su funcionalidad, mediante la implementación de la misma.
            </remarks>
        </member>
        <member name="P:Library.Effect.IEffect.IsExpired">
            <summary>
            Indica si el efecto ha expirado y debería ser eliminado del Pokémon.
            </summary>
        </member>
        <member name="M:Library.Effect.IEffect.UpdateEffect(Library.Pokemon)">
            <summary>
            Actualiza el estado del efecto en cada turno.
            </summary>
            <param name="target">El Pokémon al que se aplica el efecto.</param>
        </member>
        <member name="M:Library.Effect.IEffect.RemoveEffect(Library.Pokemon)">
            <summary>
            Elimina el efecto del Pokémon, restaurando cualquier cambio aplicado por el efecto.
            </summary>
            <param name="target">El Pokémon del que se elimina el efecto.</param>
        </member>
        <member name="T:Library.Effect.Paralysis">
            <summary>
            Representa un efecto de parálisis que puede ser aplicado a un Pokémon.
            Este efecto impide que el Pokémon objetivo ataque en algunos turnos mientras está activo.
            </summary>
            <remarks>
            Esta clase cumple con SRP "Single Responsibility Principle" ya que tiene una unica responsabilidad, manejar la
            logica del efecto Paralysis.
            </remarks>
        </member>
        <member name="F:Library.Effect.Paralysis.random">
            <summary>
            Generador de números aleatorios seguro para determinar si el Pokémon puede atacar.
            </summary>
        </member>
        <member name="M:Library.Effect.Paralysis.#ctor">
            <summary>
            Inicializa una nueva instancia del efecto de parálisis con el estado activo.
            </summary>
        </member>
        <member name="P:Library.Effect.Paralysis.IsExpired">
            <summary>
            Indica si el efecto de parálisis ha expirado y ya no debe aplicarse.
            </summary>
        </member>
        <member name="M:Library.Effect.Paralysis.UpdateEffect(Library.Pokemon)">
            <summary>
            Actualiza el efecto de parálisis en el Pokémon objetivo.
            Determina aleatoriamente si el Pokémon puede atacar, con una probabilidad del 50%.
            </summary>
            <param name="target">El Pokémon al que se le aplicará el efecto de parálisis.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="M:Library.Effect.Paralysis.RemoveEffect(Library.Pokemon)">
            <summary>
            Elimina el efecto de parálisis del Pokémon, marcándolo como expirado y restaurando su capacidad de atacar.
            </summary>
            <param name="target">El Pokémon del que se removerá el efecto.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="T:Library.Effect.Poison">
            <summary>
            Representa un efecto de veneno que puede ser aplicado a un Pokémon.
            Este efecto causa daño al Pokémon objetivo cada turno mientras está activo.
            </summary>
            /// <remarks>
            Esta clase cumple con SRP "Single Responsibility Principle" ya que tiene una unica responsabilidad, manejar la
            logica del efecto Poison.
            </remarks>
        </member>
        <member name="M:Library.Effect.Poison.#ctor">
            <summary>
            Inicializa una nueva instancia del efecto de veneno y lo marca como activo.
            </summary>
        </member>
        <member name="P:Library.Effect.Poison.IsExpired">
            <summary>
            Indica si el efecto de veneno ha expirado y ya no debe aplicarse.
            </summary>
        </member>
        <member name="M:Library.Effect.Poison.UpdateEffect(Library.Pokemon)">
            <summary>
            Aplica el daño de veneno al Pokémon objetivo, reduciendo su salud en un 5% de su salud actual.
            </summary>
            <param name="target">El Pokémon al que se le aplicará el daño por veneno.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="M:Library.Effect.Poison.RemoveEffect(Library.Pokemon)">
            <summary>
            Elimina el efecto de veneno del Pokémon.
            </summary>
            <param name="target">El Pokémon del que se removerá el efecto.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="T:Library.Effect.Sleep">
            <summary>
            Representa un efecto de sueño que puede ser aplicado a un Pokémon.
            Este efecto impide que el Pokémon pueda atacar durante un número determinado de turnos.
            </summary>
            <remarks>
            Esta clase cumple con SRP "Single Responsibility Principle" ya que tiene una unica responsabilidad, manejar la
            logica del efecto Sleep.
            </remarks>
        </member>
        <member name="F:Library.Effect.Sleep.turnsRemaining">
            <summary>
            Cantidad de turnos restantes durante los cuales el efecto de sueño estará activo.
            </summary>
        </member>
        <member name="M:Library.Effect.Sleep.#ctor">
            <summary>
            Inicializa una nueva instancia del efecto de sueño con una duración aleatoria entre 1 y 4 turnos.
            </summary>
        </member>
        <member name="M:Library.Effect.Sleep.#ctor(System.Int32)">
            <summary>
            Inicializa una nueva instancia del efecto de sueño con la duración especificada.
            </summary>
            <param name="duration">La duración del efecto de sueño en turnos.</param>
        </member>
        <member name="P:Library.Effect.Sleep.IsExpired">
            <summary>
            Indica si el efecto de sueño ha expirado y ya no debe aplicarse.
            </summary>
        </member>
        <member name="M:Library.Effect.Sleep.UpdateEffect(Library.Pokemon)">
            <summary>
            Actualiza el efecto de sueño en el Pokémon objetivo, reduciendo los turnos restantes.
            Cuando el efecto ha durado el número especificado de turnos, se elimina.
            </summary>
            <param name="target">El Pokémon al que se le aplicará el efecto de sueño.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="M:Library.Effect.Sleep.RemoveEffect(Library.Pokemon)">
            <summary>
            Elimina el efecto de sueño del Pokémon, marcándolo como expirado.
            </summary>
            <param name="target">El Pokémon del que se removerá el efecto.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="target"/> es <c>null</c>.</exception>
        </member>
        <member name="T:Library.Game">
            <summary>
            Maneja la dinamica del juego, incluye los turnos de los jugadores, ataques, y los cambios de pokemones.
            </summary>
            <remarks>
            Esta clase se podría considerar como una fachada sobre el juego de Pokemon, ya que al pasarle la conexión externa, esta
            clase se encarga de la lógica de cómo funciona el juego, escondiendo los detalles de las clases que lo implementan.
            </remarks>
        </member>
        <member name="F:Library.Game.externalConnection">
            <summary>
            La conexión al servicio externo.
            </summary>
            <remarks>
            A través de depender de una interfaz, y no una clase explícita, esta clase cumple con DIP. Esto ayuda, ya que hace a la clase más reutilizable, porque sea imprimir a la consola, discord, o algo para un test,
            únicamente requiere cambios en esta clase para lograr cambiar dónde imprime. Esto también genera cumplimiento de SRP, ya que Game se ocupa solamente de jugar el juego, interactuando con esta clase para lograr hablar con el exterior.
            </remarks>
        </member>
        <member name="F:Library.Game.playerOne">
            <summary>
            El primer jugador en el juego.
            </summary>
        </member>
        <member name="F:Library.Game.playerTwo">
            <summary>
            El segundo jugador en el juego.
            </summary>
        </member>
        <member name="M:Library.Game.#ctor(Library.Player,Library.Player,Library.IExternalConnection)">
            <summary>
            Inicializa el juego.
            </summary>
            <param name="p1">El primer jugador <see cref="F:Library.Game.playerOne"/>.</param>
            <param name="p2">El segundo jugador <see cref="F:Library.Game.playerTwo"/>.</param>
            <param name="externalConnection">La conección con el servicio externo.</param>
        </member>
        <member name="M:Library.Game.CreateGame(System.Collections.Generic.List{Library.Pokemon},Library.IExternalConnection)">
            <summary>
            Crea un nuevo juego con jugadores predefinidos.
            </summary>
            <param name="pokemon">Una lista de <see cref="T:Library.Pokemon"/> para usar en el juego.</param>
            <returns>Una nueva instancia de <see cref="T:Library.Game"/> que es hard-coded.</returns>
            <param name="externalConnection">La conección con el servicio externo.</param>
        </member>
        <member name="M:Library.Game.ShowWelcome">
            <summary>
            Shows the welcome message.
            </summary>
        </member>
        <member name="M:Library.Game.Play">
            <summary>
            Comienza el juego, va alternando el turno entre los jugadores. Este método inicia un bucle hasta que termine el juego. Para jugar de a turnos, utilice <see cref="M:Library.Game.PlayGameTurn"/>.
            </summary>
            <remarks>
            El juego continua hasta que uno de los dos jugadores se quede sin ningun pokemon en su lista. Por el momento
            siempre ataca primero el @b PlayerOne y luego **PlayerTwo**
            De todas formas entendemos que este no justo para el jugador dos por ello tendriamos que implementar algo distinto en el futuro.
            </remarks>
        </member>
        <member name="M:Library.Game.PlayGameTurn">
            <summary>
            Ejecuta un turno del juego, es decir, una acción realizada por cada jugador.
            </summary>
        </member>
        <member name="M:Library.Game.AttackPlayer(Library.Player,Library.Player)">
            <summary>
            Ejecuta un ataque por el jugador que le toca hacia el contrincante.
            </summary>
            <param name="active">El <see cref="T:Library.Player"/> que va a atacar.</param>
            <param name="other">El <see cref="T:Library.Player"/> que va a ser atacado.</param>
        </member>
        <member name="M:Library.Game.UseItem(Library.Player)">
            <summary>
            Ejecuta un ataque por el jugador que le toca hacia el contrincante.
            </summary>
            <param name="active">El <see cref="T:Library.Player"/> que va a usar items.</param>
        </member>
        <member name="M:Library.Game.PlayTurn(Library.Player,Library.Player)">
            <summary>
            Maneja el turno del jugador activo.
            </summary>
            <param name="active">El <see cref="T:Library.Player"/> que toma el turno.</param>
            <param name="other">El <see cref="T:Library.Player"/> que no le toca atacar.</param>
            <remarks>
            Todos los jugadores deben poder atacar con el pokemon seleccionado, o en cambio realizar un cambio de pokemon
            Si el usuario genera una opcion invalida tendra que realizar nuevamente una de estas dos opciones.
            </remarks>
        </member>
        <member name="M:Library.Game.ChangePokemon(Library.Player)">
            <summary>
            Deja que el jugador pueda hacer un cambio de pokemon dentro de su lista ya proporcionada en <see cref="T:Library.Player"/>.
            </summary>
            <param name="p">El <see cref="T:Library.Player"/> quien es que está haciendo el cambio.</param>
        </member>
        <member name="M:Library.Game.CheckDead(Library.Player)">
            <summary>
            Comprueba si un pokemon del jugador ha muerto.
            </summary>
            <param name="p">El <see cref="T:Library.Player"/> el cual estamos viendo el estado de su pokemon.</param>
            <returns>
            <c>true</c> Si el <paramref name="p"/> no tiene ningun Pokemon restante, sino <c>false</c>.
            </returns>
            <remarks>
            Si el ha muerto el pokemon activo de <paramref name="p"/> esta obligado a hacer un cambio de pokemon.
            </remarks>
        </member>
        <member name="T:Library.Items.IItem">
            <summary>
            Define la funcionalidad básica para un objeto que se puede utilizar en un Pokémon.
            </summary>
            /// <remarks>
            La interfaz <see cref="T:Library.Items.IItem"/> permite que distintos ítems puedan ser aplicados a un Pokémon de manera polimórfica.
            Esto permite lograr un bajo acomplamiento al crear varios items, y que sus funcionalidades sean independientes de los Pokémon.
            Esto nos ayuda el dia de mañana no generar un error, o no uno tan grande, gracias a que si ocurre un cambio, en los requisitos de los Items, ocurrirá en
            esta interfaz o una subclase, o en el caso que sea dependiente el problema seria unicamente en su uso de esta interfaz, esto haciendolo
            más felxible a la hora de añadir o modificar items o sus funcionalidades.
            Este diseño sigue DIP (Dependency Inversion Principle), ya que permite que
            otras clases interactúen con objetos de tipo <see cref="T:Library.Items.IItem"/> sin depender de
            implementaciones específicas. También sigue OCP (Open-Closed Principle), permitiendo
            que nuevos ítems se añadan sin modificar el código existente de otras clases o la interfaz.
            </remarks>
        </member>
        <member name="P:Library.Items.IItem.Name">
            <summary>
            El nombre del item.
            </summary>
        </member>
        <member name="M:Library.Items.IItem.Use(Library.Pokemon)">
            <summary>
            Aplica el efecto del objeto en el Pokémon especificado.
            </summary>
            <param name="pokemon">El Pokémon en el que se usará el objeto.</param>
        </member>
        <member name="T:Library.Items.Revive">
            <summary>
            Representa un objeto de revivir que restaura parcialmente la salud de un Pokémon debilitado.
            </summary>
            <remarks>
            La clase <see cref="T:Library.Items.Revive"/> implementa la interfaz <see cref="T:Library.Items.IItem"/> y define el comportamiento específico
            del ítem "Revive", cumpliendo con LSP.
            </remarks>
        </member>
        <member name="M:Library.Items.Revive.#ctor">
            <summary>
            Constructor establece nombre para ser imprimido al Player.
            </summary>
        </member>
        <member name="P:Library.Items.Revive.Name">
            <summary>
            Nombre de el efecto.
            </summary>
        </member>
        <member name="M:Library.Items.Revive.Use(Library.Pokemon)">
            <summary>
            Aplica el efecto del objeto Revive en el Pokémon especificado, restaurando 50 puntos de salud.
            </summary>
            <param name="pokemon">El Pokémon al que se le aplicará el Revive.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="pokemon"/> es null.
            </exception>
        </member>
        <member name="T:Library.Items.SuperPotion">
            <summary>
            Representa una super poción que cura a un Pokémon específico, restaurando una cantidad significativa de su salud.
            </summary>
        </member>
        <member name="M:Library.Items.SuperPotion.#ctor">
            <summary>
            Constructor establece nombre para ser imprimido al Player.
            </summary>
        </member>
        <member name="P:Library.Items.SuperPotion.Name">
            <summary>
            Nombre de el efecto.
            </summary>
        </member>
        <member name="M:Library.Items.SuperPotion.Use(Library.Pokemon)">
            <summary>
            Aplica el efecto de la super poción en el Pokémon especificado, restaurando 70 puntos de salud.
            </summary>
            <param name="pokemon">El Pokémon al que se le aplicará la super poción.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="pokemon"/> es null.
            </exception>
        </member>
        <member name="T:Library.Items.TotalCure">
            <summary>
            Representa un objeto que puede eliminar todos los efectos de estado negativos de un Pokémon.
            Al usar este objeto en un Pokémon, se eliminan todos los efectos de estado aplicados a él.
            </summary>
            <remarks>
            La clase <see cref="T:Library.Items.TotalCure"/> implementa la interfaz <see cref="T:Library.Items.IItem"/> y define el comportamiento específico
            de un ítem que elimina todos los efectos de estado negativos de un Pokémon.
            Esta clase también cumple con LSP, al cumplir con el contrato de la interfaz, al únicamente aplicar el efecto necesario en el Pokémon.
            Esta implementación también muestra el uso de excepciones para asegurar que el objeto se utilice correctamente.
            </remarks>
        </member>
        <member name="M:Library.Items.TotalCure.#ctor">
            <summary>
            Constructor establece nombre para ser imprimido al Player.
            </summary>
        </member>
        <member name="P:Library.Items.TotalCure.Name">
            <summary>
            Nombre de el efecto.
            </summary>
        </member>
        <member name="M:Library.Items.TotalCure.Use(Library.Pokemon)">
            <summary>
            Usa el objeto de cura total en el Pokémon especificado, eliminando cualquier efecto de estado activo.
            </summary>
            <param name="pokemon">El Pokémon al que se le aplicará la cura total.</param>
            <exception cref="T:System.ArgumentNullException">Lanzada si <paramref name="pokemon"/> es <c>null</c>.</exception>
        </member>
        <member name="T:Library.Player">
            <summary>
            Este un jugador en el juego, el cual tiene un nombre, y una lista con sus pokemons.
            El jugador puede cambiar de pokemon activo, atacar a aotro jugador y verificar si todos sus pokemons estan muertos.
            </summary>
            <remarks>
            La clase <see cref="T:Library.Player"/> esta encargada de gestionar las interacciones basicas que puede tener un jugador con
            sus pokemon a lo largo de la batalla de pokemon.
            </remarks>
        </member>
        <member name="M:Library.Player.#ctor(System.String,System.Collections.Generic.List{Library.Pokemon})">
            <summary>
            Crea una instancia del jugador con su lista de los pokemons.
            </summary>
            <param name="name">El nombre del Jugador.</param>
            <param name="pokemons">La lista de los pokemons del jugador. No puede ser null, o con otras palabras debe ser non-null.</param>
        </member>
        <member name="P:Library.Player.Name">
            <summary>
            El nombre del jugador. Esto es visible al usuario, y no es interno al codigo.
            </summary>
        </member>
        <member name="P:Library.Player.Pokemons">
            <summary>
            La lista de pokemon del jugador.
            </summary>
            <value>
            Esta lista tiene hasta 6 pokemons.
            </value>
        </member>
        <member name="P:Library.Player.Items">
            <summary>
            Lista de items disponibles para el jugador.
            </summary>
        </member>
        <member name="P:Library.Player.ActivePokemon">
            <summary>
            Este atributo hace referencia al pokemon que estaria en pantalla. Esto se acutaliza con <see cref="M:Library.Player.ChangePokemon(System.String)"/>.
            </summary>
            <value>
            Debe ser una referencia a alguno de los pokemon en la lista del jugador.
            </value>
        </member>
        <member name="M:Library.Player.ChangePokemon(System.String)">
            <summary>
            Cambia el pokemon que estaria en pantalla(<see cref="P:Library.Player.ActivePokemon"/>) del jugador.
            </summary>
            <param name="newPokemon">El nombre del pokemon por el cual quiere cambiar, este debe estar en su lista de pokemon.</param>
            <returns>
            <c>true</c> si se encontro <paramref name="newPokemon"/> en <see cref="T:Library.Pokemon"/>, sino <c>false</c> y no se cambia el pokemon <see cref="P:Library.Player.ActivePokemon"/>.
            </returns>
            <remarks>Si el <paramref name="newPokemon"/> no es encontrado en este jugador, no hacer nada.</remarks>
        </member>
        <member name="M:Library.Player.ChangePokemon(System.Int32)">
            <summary>
            Cambia el pokemon que estaria en pantalla(<see cref="P:Library.Player.ActivePokemon"/>) del jugador.
            </summary>
            <param name="pokeIdx">El índice del pokemon por el cual quiere cambiar, este debe ser válido para su lista de pokemon.</param>
            <returns>
            <c>true</c> si se cambió de Pokemon, <c>false</c> si el Pokemon nuevo era el mismo que el anterior.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Si <paramref name="pokeIdx"/> no es un índice en la lista.
            </exception>
        </member>
        <member name="M:Library.Player.Attack(Library.Player,System.String)">
            <summary>
            Ataca al <see cref="P:Library.Player.ActivePokemon"/> de <paramref name="other"/> utilizando el
            <see cref="P:Library.Player.ActivePokemon"/> del jugador con el ataque <paramref name="attackName"/>.
            </summary>
            <param name="other">El jugador a atacar. Debe ser non-null.</param>
            <param name="attackName">El nombre del ataque a utlizar. Debe ser un ataque válido de <see cref="P:Library.Player.ActivePokemon"/>.</param>
            <exception cref="T:System.ArgumentNullException">Si <paramref name="other"/> es null.</exception>
            <remarks>
            Esto llama al metodo <see cref="M:Library.Pokemon.Attack(Library.Pokemon,System.String)"/>.
            </remarks>
        </member>
        <member name="M:Library.Player.AllAreDead">
            <summary>
            Devuelve el estado de si todos los pokemons del jugador han muerto.
            </summary>
            <returns><c>true</c> si todos los pokemon del jugador estan muertos, <c>false</c> en cualquier otro caso.</returns>
        </member>
        <member name="M:Library.Player.ApplyItem(Library.Pokemon,System.String)">
            <summary>
            Aplica los Items disponibles del jugador.
            </summary>
            <param name="target">El pokémon sobre el cual usar el item.</param>
            <param name="name">El nombre del item para utilizar.</param>
        </member>
        <member name="T:Library.Pokemon">
            <summary>
            Representa una instancia de un Pokémon, con atributos específicos y ataques disponibles.
            </summary>
            <remarks>
            En esta clase podemos notar el encapsulamiento, donde **Health** y las lista de ataques **Attacks** estan
            protegidas. Las clases proporcionan un acceso a estos solo a traves de propiedas o metodos, esto ayuda a controlar
            la validacion de los mismos.
            Además, se puede ver DIP (Dependency Inversion Principle), ya que esta clase depende de la clase abstracta "Attack", y no de ninguna implementación
            concreta, así permitiendo que sea más reutilizable, ya que al agregar tipos de ataques nuevos, estos funcionarán sin modificar esta clase.
            </remarks>
        </member>
        <member name="F:Library.Pokemon.Random">
            <summary>
            Generador de random que ayuda a determinar la precision del ataque y si el mismo es critico o no.
            </summary>
        </member>
        <member name="F:Library.Pokemon.health">
             <summary>
             El valor actual de salud del pokemon.
            
             El acceso a este valor será controlado por la propiedad <see cref="P:Library.Pokemon.Health"/>.
             </summary>
        </member>
        <member name="F:Library.Pokemon.attacks">
             <summary>
             Lista de los distintos ataques con los que cuenta el pokemon.
            
             El acceso a este valor será controlado por la propiedad <see cref="P:Library.Pokemon.Attacks"/>.
             </summary>
        </member>
        <member name="M:Library.Pokemon.#ctor(System.String,Library.PokemonType,System.Int32,System.Collections.Generic.List{Library.Attack})">
            <summary>
            Inicializa una nueva instancia de la clase <see cref="T:Library.Pokemon"/> con los valores proporcionados.
            </summary>
            <param name="name">El nombre del Pokémon.</param>
            <param name="type">El tipo del Pokémon.</param>
            <param name="maxHealth">La salud máxima del Pokémon.</param>
            <param name="attacks">Lista de ataques disponibles para el Pokémon.</param>
        </member>
        <member name="M:Library.Pokemon.#ctor(Library.Pokemon)">
            <summary>
            Crea una copia del Pokémon, conservando sus atributos pero sin copiar su estado actual.
            </summary>
            <param name="pokemon">El Pokémon a clonar.</param>
            <exception cref="T:System.ArgumentNullException">
            Si <paramref name="pokemon"/> es <c>null</c>.
            </exception>
            <remarks>
            No copia el efecto, porque la idea es no copiar su estado actual.
            </remarks>
        </member>
        <member name="P:Library.Pokemon.ActiveEffect">
            <summary>
            Efecto activo que afecta al Pokémon, como veneno, parálisis, etc.
            </summary>
        </member>
        <member name="P:Library.Pokemon.Name">
            <summary>
            Nombre del Pokémon.
            </summary>
        </member>
        <member name="P:Library.Pokemon.Type">
            <summary>
            Tipo del Pokémon, que afecta la efectividad de los ataques.
            </summary>
        </member>
        <member name="P:Library.Pokemon.MaxHealth">
            <summary>
            Salud máxima del Pokémon.
            </summary>
        </member>
        <member name="P:Library.Pokemon.CanAttack">
            <summary>
            Indica si el Pokémon puede atacar en su turno.
            </summary>
        </member>
        <member name="P:Library.Pokemon.Health">
            <summary>
            Salud actual del Pokémon.
            </summary>
        </member>
        <member name="P:Library.Pokemon.Attacks">
            <summary>
            Lista de ataques disponibles para el Pokémon.
            </summary>
        </member>
        <member name="M:Library.Pokemon.Attack(Library.Pokemon,System.Int32)">
            <summary>
            Realiza un ataque sobre el Pokémon objetivo utilizando el índice especificado.
            </summary>
            <param name="target">Pokémon objetivo del ataque.</param>
            <param name="attackIdx">Índice del ataque en la lista de ataques del Pokémon.</param>
        </member>
        <member name="M:Library.Pokemon.Attack(Library.Pokemon,System.String)">
            <summary>
            Realiza un ataque sobre el Pokémon objetivo utilizando el nombre del ataque especificado.
            </summary>
            <param name="target">Pokémon objetivo del ataque.</param>
            <param name="attackName">Nombre del ataque a utilizar.</param>
        </member>
        <member name="M:Library.Pokemon.Heal(System.Int32)">
            <summary>
            Suma un valor a la salud actual del Pokémon.
            </summary>
            <param name="health">Cantidad de salud a añadir.</param>
        </member>
        <member name="M:Library.Pokemon.Damage(System.Int32)">
            <summary>
            Aplica daño al Pokémon, reduciendo su salud. El daño mínimo permitido es 0.
            </summary>
            <param name="damage">Cantidad de daño a aplicar. Debe ser mayor a 0.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Si <paramref name="damage"/> es menor a 0.
            </exception>
        </member>
        <member name="M:Library.Pokemon.ApplyEffect(Library.Effect.IEffect)">
            <summary>
            Aplica un efecto al Pokémon si no tiene un efecto activo.
            </summary>
            <param name="effect">Efecto a aplicar.</param>
        </member>
        <member name="M:Library.Pokemon.UpdateEffect">
            <summary>
            Actualiza el efecto activo del Pokémon en cada turno y lo elimina si ha expirado.
            </summary>
        </member>
        <member name="M:Library.Pokemon.RemoveEffect">
            <summary>
            Elimina el efecto activo del Pokémon, si existe.
            </summary>
        </member>
        <member name="M:Library.Pokemon.Attack(Library.Pokemon,Library.Attack)">
            <summary>
            Realiza un ataque sobre el Pokémon objetivo utilizando el ataque especificado.
            </summary>
            <param name="target">Pokémon objetivo al que se le aplicará el ataque.</param>
            <param name="attack">El ataque que se usará para realizar el daño.</param>
            <returns>
            <c>true</c> si la precision del ataque fue exitoso y el daño fue aplicado al Pokémon objetivo;
            <c>false</c> si el ataque falló.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Lanzada si el ataque especificado no se encuentra dentro de la lista <see cref="P:Library.Pokemon.Attacks"/> del Pokémon que ataca.
            </exception>
        </member>
        <member name="M:Library.Pokemon.GetAttack(System.String)">
            <summary>
            Retorna el ataque correspondiente al nombre especificado.
            </summary>
            <param name="attackName">
            El nombre del ataque al cual se quiere acceder.
            </param>
            <returns>El ataque correspondiente al nombre provisto.</returns>
            <exception cref="T:System.InvalidOperationException">
            Lanzada si el Pokémon no tiene ataques disponibles.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Lanzada si <paramref name="attackName"/> no es el nombre de ningún ataque.
            </exception>
        </member>
        <member name="M:Library.Pokemon.GetAttack(System.Int32)">
            <summary>
            Retorna el ataque correspondiente al índice especificado.
            </summary>
            <param name="attackIdx">
            Índice del ataque en la lista de ataques.
            </param>
            <returns>El ataque correspondiente al índice provisto.</returns>
            <exception cref="T:System.InvalidOperationException">
            Lanzada si el Pokémon no tiene ataques disponibles.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Lanzada si el índice <paramref name="attackIdx"/> está fuera del rango permitido (0-(cant. ataques - 1)).
            </exception>
        </member>
        <member name="T:Library.PokemonRegistry">
            <summary>
            Colección de Pokémon pre-definidos.
            </summary>
            <remarks>
            Se podría decir que es una implementación de <see href="https://refactoring.guru/design-patterns/prototype">Prototype</see>.
            Esto es porque esta clase permite conseguir un objeto de la clase Pokemon sin conocer su estructura, a través de el nombre del objeto, clonando un prototipo pre-definido.
            </remarks>
        </member>
        <member name="F:Library.PokemonRegistry.PokemonTemplates">
            <summary>
            El diccionario entre nombre de Pokemon y Pokemon. Lo devuelto al usuario será una copia de un elemento de este diccionario.
            </summary>
            <remarks>
            Estos son los primero 40 y algo, y algunos al final que quería poner porque eran piola.
            </remarks>
        </member>
        <member name="M:Library.PokemonRegistry.GetPokemon(System.String)">
            <summary>
            Retorna una copia del Pokémon cuyo nombre es <paramref name="name"/>, si se encuentra en el registro.
            </summary>
            <param name="name">El nombre del <see cref="T:Library.Pokemon"/>.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Si el Pokémon no está en el registro.
            </exception>
            <returns>
            Una copia del Pokémon cuyo nombre es <paramref name="name"/>.
            </returns>
        </member>
        <member name="M:Library.PokemonRegistry.GetAllPokemon">
            <summary>
            Retorna una lista de todos los Pokemon del registro.
            </summary>
            <returns>
            Lista de todos los Pokemon del registro.
            </returns>
        </member>
        <member name="M:Library.PokemonRegistry.GetPokemonNamesAndTypes">
            <summary>
            Retorna una lista de tuplas donde cada una es el nombre y tipo de un Pokémon del registro.
            </summary>
            <returns>
            Lista de (Nombre, Tipo).
            </returns>
        </member>
        <member name="T:Library.PokemonType">
            <summary>
            Enumera los diferentes tipos de Pokemon, cada uno con una cierta ventaja y desventaja sobre otro tipo.
            </summary>
            <remarks>
            A través del uso de esta enumeración, logramos cumplir con SRP, ya que a través de esta, se manejan las interacciones entre todos los tipos, que luego son utilizados a través del método <see cref="M:Library.Calculate.Advantage(Library.PokemonType,Library.PokemonType)"/>.
            </remarks>
        </member>
        <member name="F:Library.PokemonType.Normal">
            <summary>
            El tipo normal.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Fire">
            <summary>
            El tipo Fire.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Water">
            <summary>
            El tipo Water.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Electric">
            <summary>
            El tipo Electric.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Grass">
            <summary>
            El tipo Grass.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Ice">
            <summary>
            El tipo Ice.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Fighting">
            <summary>
            El tipo Fighting.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Poison">
            <summary>
            El tipo Poison.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Ground">
            <summary>
            El tipo Ground.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Flying">
            <summary>
            El tipo Flying.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Psychic">
            <summary>
            El tipo Psychic.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Bug">
            <summary>
            El tipo Bug.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Rock">
            <summary>
            El tipo Rock.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Ghost">
            <summary>
            El tipo Ghost.
            </summary>
        </member>
        <member name="F:Library.PokemonType.Dragon">
            <summary>
            El tipo Dragon.
            </summary>
        </member>
        <member name="T:Library.Calculate">
            <summary>
            Provee los metodos para calcular la efectividad de los tipos de los Pokemons en la batalla.
            </summary>
        </member>
        <member name="M:Library.Calculate.Advantage(Library.PokemonType,Library.PokemonType)">
            <summary>
            Este determina la ventaja del Pokemon atacante, sobre el Pokemon atacado.
            </summary>
            <remarks>
            Si el tipo <paramref name="defender"/> no está explícitamente mencionado como "strong",
            "weak" o "immune" en la tabla del tipo <paramref name="attacker"/>, se considera un
            multiplicador de 1.0 (neutral).
            </remarks>
            <param name="attacker">El tipo del ataque utilizado.</param>
            <param name="defender">El tipo del Pokemon atacado.</param>
            <returns>
            Un double que representa la efectividad.
            <item>2.0 si <paramref name="attacker"/> es fuerte contra <paramref name="defender"/></item>
            <item>0.5 si <paramref name="attacker"/> es debil contra <paramref name="defender"/></item>
            <item>0.0 si <paramref name="attacker"/> no tiene efecto en <paramref name="defender"/></item>
            <item>1.0 si no hay ventaja entre ambos tipos</item>
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Lanza esta excepcion si <paramref name="attacker"/> es un tipo que no tiene ventajas explicitadas.
            </exception>
        </member>
        <member name="T:Library.ConsoleConnection">
            <summary>
            Un <see cref="T:Library.IExternalConnection"/> que imprime/toma entrada de la consola.
            </summary>
            <remarks>
            Cumple con SRP "Single Responsability Principle", ya que su unica responsabilidad es manejar la interaccion con la consola.
            Cumple con LSP "Liskov Substitution Principle" ya que al implementar el contrato de la interfaz, se puede utilizar en cualquier lugar
            que se utilize la interfaz, mantienendo el comportamiento esperado.
            Cumple con DIP "Dependency Inversion Principle" debido a que clases de alto nivel dependen de la
            interfaz IExternalConnection en lugar de depender de ConsoleConnection directamente. Esto permite que las clases de alto nivel
            puedan funcionar sin estar acopladas a una implementación concreta.
            </remarks>
        </member>
        <member name="M:Library.ConsoleConnection.PrintString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.PrintWelcome(Library.Player,Library.Player)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.PrintPlayerWon(Library.Player,Library.Player)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.PrintTurnHeading(Library.Player)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.ShowMenuAndReceiveInput(System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.ShowAttacksAndRecieveInput(Library.Pokemon)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.ReportAttackResult(System.Int32,Library.Player,Library.Player)">
            <inheritdoc/>
        </member>
        <member name="M:Library.ConsoleConnection.ShowChangePokemonMenu(Library.Player)">
            <inheritdoc/>
        </member>
        <member name="T:Library.IExternalConnection">
            <summary>
            Representa la comunicación a un servicio externo.
            Permite imprimir texto, y pedirlo al usuario una selección.
            </summary>
            <remarks>
            Esta interfaz cumple con OCP "Open-Closed Principle" si se neccesita cambiar como se imprime la informcacio, se puede
            crear nuevas implementacion sin modificar la interzas original.
            Tambien cumple con DIP "Dependency Inversion Principle" al abstraer la funcionalidad de la impresion y permitir que
            las clases de alto nivel (como la interacción con el usuario) dependan de la interfaz en lugar de depender de una
            implemntacion contreta. Esto nos da en el codigo una mayor flexibilidad y descaoplamiento.
            La interfaz aplica multiples metodos, sin embargo estan todos relacionados con la impresdion, lo que
            mantiene una alta cohesion en la misma.
            La interfaz cumple tambien con SRP "Single Responsability Principle" ya que encapsula el tema de "Comunicarse con el
            usuario", y esta al tener solo un unico proposito tambien tiene solo una razon de cambio, que querramos cambiar como
            se habla con el usuario, y gracias a esto generamos un bajo acomplamiento.
            Por supuesto, esta interfaz también hace uso de LSP, ya que una implementación debe cumplir con el contrato de la interfaz,
            y una vez esto se logra esta implementación se puede utilizar donde sea que se necesita esta interfaz, logrando más flexibilidad.
            </remarks>
        </member>
        <member name="M:Library.IExternalConnection.PrintString(System.String)">
            <summary>
            Imprime la string pasada al servicio.
            </summary>
            <param name="str">La string a imprimir.</param>
        </member>
        <member name="M:Library.IExternalConnection.PrintWelcome(Library.Player,Library.Player)">
            <summary>
            Imprime el mensaje de bienvenida a ambos usuarios.
            </summary>
            <param name="p1">El primer jugador.</param>
            <param name="p2">El segundo jugador.</param>
        </member>
        <member name="M:Library.IExternalConnection.PrintPlayerWon(Library.Player,Library.Player)">
            <summary>
            Imprime el mensaje de victoria para el primer jugador. Además, debería indicar que terminó la partida, y hacer algo al respecto.
            </summary>
            <param name="p1">El jugador ganador.</param>
            <param name="p2">El jugador perdedor.</param>
        </member>
        <member name="M:Library.IExternalConnection.PrintTurnHeading(Library.Player)">
            <summary>
            Imprime la indicación del comienzo del turno del jugador 1.
            </summary>
            <param name="player">El jugador cuyo turno es.</param>
        </member>
        <member name="M:Library.IExternalConnection.ShowMenuAndReceiveInput(System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary>
            Le imprime las opciones recibidas, y le permite eligir una opción al usuario mediante un número o el nombre de la opción.
            Si la opción ingresada fue inválida, este método deberá reintentar hasta lograr una entrada correcta.
            </summary>
            <param name="selectionText">El texto a mostrar para contextualizar las opciones. El texto se muestra antes de las mismas.</param>
            <param name="options">Los elementos que se pueden elegir del menú.</param>
            <returns>
            El índice, relativo al array <paramref name="options"/> de la opción elegida.
            </returns>
        </member>
        <member name="M:Library.IExternalConnection.ShowAttacksAndRecieveInput(Library.Pokemon)">
            <summary>
            Le imprime la lista de ataques del pokemon recibido, y le permite eligir una opción al usuario mediante un número o el nombre del ataque.
            Si la opción ingresada fue inválida, este método deberá reintentar hasta lograr una entrada correcta.
            </summary>
            <param name="pokemon">El pokemon cuyos ataques se elegirán.</param>
            <returns>
            El nombre del ataque que eligió el usuario, o <c>null</c> si el usuario se arrepintió y quiso volver atrás.
            </returns>
        </member>
        <member name="M:Library.IExternalConnection.ShowChangePokemonMenu(Library.Player)">
            <summary>
            Le muestra al usuario la lista de Pokemon, y le permite elegir uno. Además, le indica una opción para arrepentirse y no cambiar de Pokémon.
            </summary>
            <param name="player">El jugador que quiere cambiar de Pokemon.</param>
            <returns>
            El índice en la lista de Pokemon del Pokemon que se eligió. <c>0</c>indica que el usuario quiere volver.
            </returns>
        </member>
        <member name="M:Library.IExternalConnection.ReportAttackResult(System.Int32,Library.Player,Library.Player)">
            <summary>
            Le muestra al usuario el resultado que tuvo su ataque.
            </summary>
            <param name="oldHP">La vida del pokemon de <paramref name="defender"/> antes de ser atacado.</param>
            <param name="attacker">El jugador que atacó.</param>
            <param name="defender">El jugador que fue atacado.</param>
        </member>
    </members>
</doc>
